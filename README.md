# Team-B8 | Hotelreservierungssystem

## Autoren
<p>Yaren Akinci</p>
<p>Kerem Akkaya</p>
<p>Lou Brauchli</p>
<p>Haris Salii</p>

## Ressourcen
- Link zur Deepnote-Dokumentation: [Projektdokumentation](https://deepnote.com/workspace/BAI-Projekte-8a9d47a8-bcd7-44ff-8444-0996c6ccb0b9/project/AEP-Hotelreservierungsysstem-Team-B8-a048451d-c7e6-46c3-a824-c0d893d5e1b2/notebook/Projektdokumentation-0a3411e6d6224bf6bff262c03516407d)
- Link zu den Scrum Meetings und Sprint Reviews: [Scrum Meetings und Sprint Reviews](https://deepnote.com/workspace/BAI-Projekte-8a9d47a8-bcd7-44ff-8444-0996c6ccb0b9/project/AEP-Hotelreservierungsysstem-Team-B8-a048451d-c7e6-46c3-a824-c0d893d5e1b2/notebook/Sprint-1-224529094ca64f09810e7c2a8671c092?utm_content=a048451d-c7e6-46c3-a824-c0d893d5e1b2)
- Link zum Scrum Board: [Scrum Board](https://github.com/orgs/Team-B8/projects/1)
- Link zum Miro Board: [Miro Board](https://miro.com/app/board/uXjVLXdcWpw=/)

## Methodologie / Projektmanagement
### Projektmanagement mit Scrum

F√ºr das Projektmanagement wurde die agile Scrum-Methode eingesetzt. Die vier Unterrichtseinheiten wurden jeweils als einzelne Sprints organisiert, wobei jedes Teammitglied einmal die Rolle des Scrum Masters √ºbernahm.

- Die Aufgabenverteilung erfolgte √ºber GitHub Projects durch den Scrum Master.
- Die Zusammenarbeit und der Fortschritt wurden kontinuierlich auf Deepnote dokumentiert.
- Individuelle Beitr√§ge wurden dort festgehalten und in w√∂chentlichen Scrum-Meetings besprochen.
- Die Kommunikation lief haupts√§chlich √ºber Microsoft Teams, inklusive zus√§tzlicher Besprechungen zur Projektbearbeitung.
- Am Ende jedes Sprints fand ein Sprint Review statt, in dem der aktuelle Projektstand bewertet wurde. Diese wurden auf Miro dokumentiert.
- Bewertungen, offene Aufgaben und neue Ziele wurden auf einem gemeinsamen Scrum Board festgehalten.

#### Sprint 1 ‚Äì Einstieg ins Projekt

Ziele:
- Grundlagen von Python kennenlernen
- Erste Programmier√ºbungen durchf√ºhren
- Projektbeschrieb verstehen
- Struktur f√ºr die Dokumentation erarbeiten

#### Sprint 2 ‚Äì Objektorientierung & Projektstruktur

Ziele:
- Verst√§ndnis der Unterrichtsinhalte mit Fokus auf Object Oriented Programming (OOP)
- Verkn√ºpfung der bisherigen Konzepte
- Erstellung eines UML-Diagramms als Basis f√ºr die Model-Schicht (Gesch√§ftsobjekte)

#### Sprint 3 ‚Äì Umsetzung & Dokumentation

Ziele:
- Modellierung einzelner Systemkomponenten
- Umsetzung erster User Stories
- Dokumentation der Ergebnisse
- Weiterf√ºhrung und Anwendung der Theorieinhalte auf das Projekt

#### Sprint 4 ‚Äì Finalisierung

Ziele:
- Abarbeiten aller offenen Aufgaben
- Pr√ºfung der Funktionalit√§t
- Abgabe der vollst√§ndigen Projektarbeit inkl. Dokumentation

#### Fazit

Durch den Einsatz von Scrum konnte eine strukturierte, zielorientierte und zugleich flexible Arbeitsweise etabliert werden. Alle Teammitglieder waren aktiv in Planung, Umsetzung und Reflexion eingebunden.

### Tools 
<P>Deepnote: Codieren und Dokumentation</p>
<P>Python 3.13</p>
<P>Visual Paradigm: Modellierung ERD und UML</p>
<p>Visual Studio Code: Codieren</p>
<p>GitHub: Systemablage, Systemadmninistration, Aufgabenverteilung</p>
<p>Teams: Kommunikation, Video-Calls</p>
<p>Miro: Sprint Reviews und Sprint Retrospective</p>

### Projektbeitr√§ge
#### Teamarbeit und Rollenverteilung im Projekt

W√§hrend des Projekts arbeiteten alle Teammitglieder gemeinsam an der Umsetzung des Hotelreservierungssystems. In den ersten Sprints lag der Fokus auf der Einarbeitung in die Projektumgebung, den verwendeten Tools wie GitHub und Miro, sowie auf dem Erlernen der Grundlagen in Python und der objektorientierten Programmierung. Alle Mitglieder beteiligten sich aktiv an diesen Vorbereitungen und erarbeiteten sich das notwendige Wissen im Team.

Im weiteren Verlauf verschob sich der Schwerpunkt auf die Modellierung des Systems, die Erstellung und Umsetzung von User Stories sowie auf die fortlaufende Dokumentation. Alle Teammitglieder waren in die Implementierung, das Testen sowie die Programmierarbeit involviert.

#### Rollen und Beitr√§ge im Detail

**Yaren Akinci (Scrum Master ‚Äì Sprint 2)**

- Verantwortlich f√ºr die Organisation des Teams im zweiten Sprint  
- Intensive Auseinandersetzung mit Projekt-Guidelines sowie den Prinzipien KISS und DRY 
- Umsetzung von User Stories  
- Pflege und Korrektur der Projektdokumentation

**Kerem Akkaya (Scrum Master ‚Äì Sprint 4)**

- Scrum Master im finalen Sprint  
- Aktive Beteiligung an der Implementierung und Korrektur von Projektinhalten  
- Wiederholung und Anwendung zentraler Unterrichtsinhalte (z.‚ÄØB. *Complete User Story*)  
- Verfasser von Teilen der Dokumentation

**Lou Brauchli (Scrum Master ‚Äì Sprint 3)**

- Fokus auf technische Dokumentation und Modellierung 
- Erstellung und Aktualisierung des UML-Diagramms
- Kommentierung des Codes und umfassende Dokumentation der User Stories in Deepnote
- Leitung der Umsetzung der Programmierung im dritten Sprint

**Haris Salii (Scrum Master ‚Äì Sprint 1)**

- √úbernahm fr√ºhzeitig die Verantwortung f√ºr die Tool-Infrastruktur 
- Fokus auf die Implementierung der User Story-Logik in sp√§teren Sprints  
- Technische Unterst√ºtzung in der Systementwicklung

#### Zusammenarbeit und Fazit

Alle Teammitglieder wirkten an der Dokumentation, den User Stories sowie dem Projektmanagement aktiv mit.  
Dank der klaren Rollenverteilung, der effizienten Kommunikation und der engagierten Teamarbeit konnte das Projekt planm√§ssig abgeschlossen und erfolgreich abgegeben werden.

### Wichtige Entscheidungen
#### 1. Modularer Aufbau des Systems

Zu Beginn wurde das System in vier Module aufgeteilt:

- `ui_folder` f√ºr die Benutzeroberfl√§che  
- `business_logic` f√ºr die Gesch√§ftslogik  
- `data_access` f√ºr den Zugriff auf die Datenbank  
- `model` f√ºr die Datenstrukturen

Diese Trennung sorgte f√ºr mehr √úbersicht. Jeder Bereich hatte eine klare Aufgabe. Das machte die Arbeit im Team einfacher, da Aufgaben klar verteilt werden konnten. Neue Funktionen liessen sich gezielt in einem Modul erg√§nzen, ohne andere Teile zu beeinflussen. Auch Tests und Erweiterungen wurden dadurch einfacher.

#### 2. Klassen mit Properties und Kapselung

F√ºr Objekte wie `Guest`, `Hotel` oder `Booking` haben wir private Attribute und `@property`-Methoden eingesetzt. Dadurch konnten wir die Daten absichern. √Ñnderungen an Attributen waren nur √ºber definierte Schnittstellen m√∂glich. So wurden ung√ºltige Zust√§nde verhindert. Validierungen konnten direkt in der Klasse eingebaut werden. Das st√§rkte die Kapselung und sorgte f√ºr saubere, wartbare Klassen.

#### 3. Entwicklung anhand von User Stories

Alle Funktionen wurden entlang der vorgegebenen User Stories umgesetzt. Jede Story stand f√ºr ein konkretes Ziel. Bevor die n√§chste angefangen wurde, musste die aktuelle vollst√§ndig umgesetzt, getestet und dokumentiert sein. Diese klare Struktur half, den Fokus zu halten und das Projekt Schritt f√ºr Schritt stabil aufzubauen.

#### 4. Dynamische Preisberechnung im `InvoiceManager`

Die Preisberechnung sollte je nach Saison angepasst werden. Daf√ºr wurde eine zentrale Methode `calculate_dynamic_price()` im `InvoiceManager` erstellt. So blieb die Logik an einer Stelle und musste nicht mehrfach im Code eingebaut werden. Das senkte die Fehleranf√§lligkeit und machte sp√§tere Anpassungen einfacher.

#### 5. Flexible Stammdatenverwaltung mit Einschr√§nkungen

F√ºr die Verwaltung von Zimmertypen, Einrichtungen und Preisen wurde ein Men√º in `input_helper.py` entwickelt. Hier kann der Admin neue Eintr√§ge hinzuf√ºgen oder bestehende bearbeiten. Gel√∂scht werden kann aber nur, was nicht mehr verwendet wird ‚Äì zum Beispiel keine Zimmerkategorie, die noch in Buchungen vorkommt. Diese Einschr√§nkung verhindert fehlerhafte Zust√§nde in der Datenbank.

#### 6. Rechnung direkt bei Buchung erzeugen

Laut urspr√ºnglicher Anforderung sollte die Rechnung erst nach dem Aufenthalt erstellt werden. Wir haben uns aber bewusst daf√ºr entschieden, die Rechnung sofort bei der Buchung zu generieren. So war sichergestellt, dass zu jeder Buchung eine vollst√§ndige Rechnung existiert ‚Äì inklusive Preisberechnung. Das machte sp√§tere Auswertungen einfacher und verhinderte vergessene Rechnungen.

#### 7. Einsatz des ERD als feste Referenz

Das relationale Datenmodell wurde vor der Implementierung als ER-Diagramm entworfen. Dieses Diagramm wurde im Projektverlauf regelm√§ssig genutzt, um sicherzustellen, dass Struktur und Umsetzung √ºbereinstimmen. So konnten Inkonsistenzen zwischen Code und Datenbank vermieden werden. Das ERD diente als gemeinsame Grundlage f√ºr alle Entscheidungen rund um die Datenstruktur.

#### 8. Zugriffsschutz in der Model-Ebene
Die Attribute in den Klassen der Model-Ebene haben wir als privat deklariert. Dadurch soll sichergestellt werden, dass von aussen nicht direkt auf die Daten zugegriffen oder sie ungewollt ver√§ndert werden k√∂nnen. Um trotzdem kontrollierten Zugriff zu erm√∂glichen, haben wir gezielt Getter- und Setter-Methoden erstellt. So behalten wir die Kontrolle dar√ºber, wie und wann bestimmte Werte gelesen oder ge√§ndert werden. Z.B k√∂nnen in den Settern auch einfache Pr√ºfungen erg√§nzt werden. 

## ERD Diagramm
![ERD Diagramm](/images/ERD_Hotelreservierung.jpg)

## UML Diagramm
![UML Diagramm](/images/UML_Hotelreservierung.jpg)

## Projektstruktur
Das Projekt ist nach dem klassischen Schichtenmodell aufgebaut, um eine klare Trennung der Verantwortlichkeiten zwischen Benutzeroberfl√§che, Gesch√§ftslogik, Datenzugriff und Datenmodellierung zu gew√§hrleisten. Der Projektordner team-b8-hotelreservierungssystem enth√§lt die folgenden zentralen Komponenten:

### Layers
#### User Interface
Der Ordner ui_folder/ enth√§lt die Komponenten, die f√ºr die Interaktion mit den Benutzer:innen zust√§ndig sind. Hier wird die Eingabe entgegengenommen und die Ausgabe erzeugt. Die UI ruft Funktionen aus der Business Logic auf und zeigt deren Ergebnisse an. In dieser Schicht erfolgt keine direkte Datenverarbeitung oder Datenbankabfrage.

#### Business Logic
Im Verzeichnis business_logic/ befindet sich die gesamte Gesch√§ftslogik des Systems. Jede wichtige Funktionalit√§t, wie z.‚ÄØB. das Verwalten von Buchungen, Hotels, G√§sten, Rechnungen oder Bewertungen, ist in einer eigenen Manager-Klasse gekapselt. Diese Manager arbeiten mit den Datenmodellen aus dem model/-Verzeichnis und verwenden die Data Access Layer (DAL), um Daten abzurufen oder zu speichern. Die Business Logic stellt damit die zentrale Verarbeitungs- und Entscheidungsschicht des Systems dar.

#### Data Access Layer
Der Ordner data_access/ enth√§lt die Datenzugriffslogik. Hier befinden sich Klassen, die den Zugriff auf die SQLite-Datenbank kapseln. Jede Dom√§ne (z.‚ÄØB. Hotel, Gast, Bewertung) hat ihr eigenes Data Access Object, das in einer separaten Datei implementiert ist. Diese Schicht stellt Methoden bereit, um Datenbankoperationen (z.‚ÄØB. SELECT, INSERT, UPDATE, DELETE) auszuf√ºhren. Der Zugriff erfolgt ausschlie√ülich √ºber diese Schicht. Weder UI noch Business Logic kommunizieren direkt mit der Datenbank.

#### Model
Im model/-Verzeichnis sind die Datenstrukturen, mit denen innerhalb des Systems gearbeitet wird. Jede Klasse repr√§sentiert eine zentrale Entit√§t des Hotelreservierungssystems, wie z.‚ÄØB. Guest, Room, Booking oder Rating. Diese Klassen enthalten Konstruktoren, Attribute ( mit privaten Zugriffen), sowie Methoden zur Darstellung oder Modifikation von Instanzdaten. Sie halten die relevanten Informationen wie z.‚ÄØB. Namen, IDs oder Buchungsdaten und werden von den verschiedenen Schichten genutzt, um damit weiterzuarbeiten.

#### Data Base
Der Ordner database/ enth√§lt die SQLite-Datenbanken, die f√ºr Entwicklung und Test genutzt werden, sowie das zugeh√∂rige SQL-Skript zur Erstellung der Tabellenstruktur. Die Datei hotel_reservation_samp_scriptle.sql definiert dabei den Aufbau der Datenbank, w√§hrend z.‚ÄØB. hotel_reservation_db.db die aktuell verwendete SQLite-Datenbank enth√§lt.

## Ausf√ºhrung des Programms

Das Hotelreservierungssystem kann auf zwei Arten ausgef√ºhrt werden:

### Option 1: Ausf√ºhrung auf Deepnote (empfohlen)

Die User Stories k√∂nnen in Deepnote ausgef√ºhrt werden ‚Äì **mit Ausnahme von User Story 14**, da dort das Modul `geopy` verwendet wird, welches in Deepnote nicht installiert werden kann.

Hier kann man direkt den Codeblock auf Deepnote √∂ffnen:  
[Codeblock zum Ausf√ºhren der User Stories](https://deepnote.com/workspace/BAI-Projekte-8a9d47a8-bcd7-44ff-8444-0996c6ccb0b9/project/AEP-Hotelreservierungsysstem-Team-B8-a048451d-c7e6-46c3-a824-c0d893d5e1b2/notebook/Projektdokumentation-0a3411e6d6224bf6bff262c03516407d#0abc00525e5c472a95bbecd7d26bfae6)

**Wichtig:** In Deepnote muss **nur der markierte Codeblock** zur Ausf√ºhrung der User Story gestartet werden ‚Äì **nicht** die Codebl√∂cke innerhalb der Projektdokumentation!

### Option 2: Lokale Ausf√ºhrung

Das Projekt kann auch vollst√§ndig lokal ausgef√ºhrt werden. Daf√ºr wird eine Python-Umgebung (empfohlen: Python 3.10+) ben√∂tigt. Die folgenden Bibliotheken sollten daf√ºr installiert sein:

```bash
pip install pandas matplotlib seaborn geopandas folium geopy
```

### Projekt starten

Navigiere in das Projektverzeichnis und f√ºhre im Terminal folgenden Befehl aus:

```bash
python ui_folder/input_helper.py
```

Damit wird das textbasierte UI gestartet, in dem alle User Stories interaktiv getestet werden k√∂nnen.

### Voraussetzungen
- Python 3.10 oder h√∂her
- Virtuelle Umgebung empfohlen (venv)
- SQLite-Datenbank im Ordner database/ vorhanden
 
## User Stories
Folgend werden nur die umgesetzten User Stories abgebildet. Eine ausf√ºhrliche Dokumentation der User Stories ist auf Deepnote zu finden.
### Minimale User Stories
#### 1. Als Gast m√∂chte ich die verf√ºgbaren Hotels durchsuchen, damit ich dasjenige ausw√§hlen kann, welches meinen W√ºnschen entspricht. W√ºnsche sind:
1.1. Ich m√∂chte alle Hotels in einer Stadt durchsuchen, damit ich das Hotel nach meinem bevorzugten Standort (Stadt) ausw√§hlen kann.

1.2. Ich m√∂chte alle Hotels in einer Stadt nach der Anzahl der Sterne (z.B. mindestens 4 Sterne) durchsuchen.

1.3. Ich m√∂chte alle Hotels in einer Stadt durchsuchen, die Zimmer haben, die meiner G√§stezahl entsprechen (nur 1 Zimmer pro Buchung).

1.4. Ich m√∂chte alle Hotels in einer Stadt durchsuchen, die w√§hrend meines Aufenthaltes ("von" (check_in_date) und "bis" (check_out_date)) Zimmer zur Verf√ºgung haben, damit ich nur relevante Ergebnisse sehe.

1.5. Ich m√∂chte W√ºnsche kombinieren k√∂nnen, z.B. die verf√ºgbaren Zimmer zusammen mit meiner G√§stezahl und der mindest Anzahl Sterne.

1.6. Ich m√∂chte die folgenden Informationen pro Hotel sehen: Name, Adresse, Anzahl der Sterne.

#### 2. Als Gast m√∂chte ich Details zu verschiedenen Zimmertypen (Single, Double, Suite usw.), die in einem Hotel verf√ºgbar sind, sehen, einschliesslich der maximalen Anzahl von G√§sten f√ºr dieses Zimmer, Beschreibung, Preis und Ausstattung, um eine fundierte Entscheidung zu treffen.
2.1. Ich m√∂chte die folgenden Informationen pro Zimmer sehen: Zimmertyp, max. Anzahl der G√§ste, Beschreibung, Ausstattung, Preis pro Nacht und Gesamtpreis.

2.2. Ich m√∂chte nur die verf√ºgbaren Zimmer sehen, sofern ich meinen Aufenthalt (von ‚Äì bis) spezifiziert habe.

#### 3. Als Admin des Buchungssystems m√∂chte ich die M√∂glichkeit haben, Hotelinformationen zu pflegen, um aktuelle Informationen im System zu haben.
3.1. Ich m√∂chte neue Hotels zum System hinzuf√ºgen

3.2. Ich m√∂chte Hotels aus dem System entfernen

3.3. Ich m√∂chte die Informationen bestimmter Hotels aktualisieren, z. B. den Namen, die Sterne usw.

#### 4. Als Gast m√∂chte ich ein Zimmer in einem bestimmten Hotel buchen, um meinen Urlaub zu planen.
#### 5. Als Gast m√∂chte ich nach meinem Aufenthalt eine Rechnung erhalten, damit ich einen Zahlungsnachweis habe.
Hint: F√ºgt einen Eintrag in der ¬´Invoice¬ª Tabelle hinzu.
#### 6. Als Gast m√∂chte ich meine Buchung stornieren, damit ich nicht belastet werde, wenn ich das Zimmer nicht mehr ben√∂tige.
Hint: Sorgt f√ºr die entsprechende Invoice.
#### 7. Als Gast m√∂chte ich eine dynamische Preisgestaltung auf der Grundlage der Nachfrage sehen, damit ich ein Zimmer zum besten Preis buchen kann.
Hint: Wendet in der Hochsaison h√∂here und in der Nebensaison niedrigere Tarife an.
#### 8. Als Admin des Buchungssystems m√∂chte ich alle Buchungen aller Hotels sehen k√∂nnen, um eine √úbersicht zu erhalten.
#### 9. Als Admin m√∂chte ich eine Liste der Zimmer mit ihrer Ausstattung sehen, damit ich sie besser bewerben kann.
#### 10. Als Admin m√∂chte ich in der Lage sein, Stammdaten zu verwalten, z.B. Zimmertypen, Einrichtungen, und Preise in Echtzeit zu aktualisieren, damit das Backend-System aktuelle Informationen hat.
Hint: Stammdaten sind alle Daten, die nicht von anderen Daten
abh√§ngen.

### User Stories mit DB-Schema√§nderung

#### 3. Als Gast m√∂chte ich nach meinem Aufenthalt eine Bewertung f√ºr ein Hotel abgeben, damit ich meine Erfahrungen teilen kann.
#### 4. Als Gast m√∂chte ich vor der Buchung Hotelbewertungen lesen, damit ich das beste Hotel ausw√§hlen kann.

### User Stories mit Datenvisualisierung

#### 1. Als Admin m√∂chte ich die Belegungsraten f√ºr jeden Zimmertyp in meinem Hotel sehen, damit ich weiss, welche Zimmer am beliebtesten sind und ich meine Buchungsstrategien optimieren kann. Hint: W√§hlt ein geeignetes Diagramm, um die Auslastung nach Zimmertyp darzustellen (z. B. wie oft jeder Zimmertyp gebucht wird).

### Optionale User Stories

#### 1. Als Admin m√∂chte ich die Gesamteinnahmen meines Hotels sehen, damit ich die finanzielle Leistung des Hotels analysieren kann.
1.1. Zeigt die Gesamteinnahmen (Revenue) an, die sich aus allen Buchungen f√ºr einen bestimmten Zeitraum ergeben.

1.2. Eine zeitliche Aufschl√ºsselung (z. B. Umsatz nach Monat, Quartal, Jahr) bereitstellen. Hint: F√ºge eine Trendlinie ein, um zu veranschaulichen, wie sich die Einnahmen im Laufe der Zeit ver√§ndern.

#### 3. Als Gastnutzer m√∂chte ich eine Karte mit Zoom- und Filterfunktion sehen k√∂nnen, welche Sehensw√ºrdigkeiten oder Restaurants in der N√§he meines gebuchten Hotels liegen, um meine Aufenthaltsplanung zu erleichtern. Hint: Verwende die Python-Bibliothek ¬´geopandas¬ª oder eine √§hnliche.

## Projekterkenntnisse

### 1. Projektstruktur und Modularisierung

Schon zu Beginn war klar, wie wichtig eine saubere Struktur ist. Wir haben die Anwendung in vier Hauptbereiche aufgeteilt: **Benutzeroberflaeche (`ui_folder`)**, **Geschaeftslogik (`business_logic`)**, **Datenzugriff (`data_access`)** und **Datenmodelle (`model`)**. Diese Trennung hat geholfen, den √úberblick zu behalten. Neue Funktionen konnten gezielt in einem Bereich umgesetzt werden, ohne andere Teile zu st√∂ren. Auch das Testen wurde einfacher, weil die Logik klar voneinander getrennt war. Das hat die Wartbarkeit und Erweiterbarkeit des Projekts deutlich verbessert.

### 2. Datenkonsistenz in relationalen Datenbanken

Im Umgang mit SQLite wurde deutlich: Konsistenz zwischen Tabellen ist zentral. Bei verkn√ºpften Daten wie `Guest`, `Booking`, `Room` und `Invoice` traten schnell Probleme auf, wenn Foreign Keys fehlten oder falsche Werte gespeichert wurden. Durch korrekte Verkn√ºpfungen und Validierungen konnten wir solche Fehler vermeiden. Auch kleinere Anomalien, etwa doppelte Buchungen oder ung√ºltige Verweise, wurden so verhindert.

### 3. Fehlermanagement

Fehlermeldungen sind nicht nur f√ºr Entwickler wichtig. Auch Nutzer m√ºssen verstehen, was schieflief. Wir haben mit `try-except`-Bloecken gearbeitet, um Fehler fr√ºhzeitig abzufangen. F√ºr die Benutzeroberfl√§che wurden klare R√ºckmeldungen formuliert, zum Beispiel bei ung√ºltigen Eingaben oder fehlenden Daten. So konnten wir Probleme schneller erkennen und gezielt beheben.

### 4. Getter, Setter und Kapselung im Klassendesign

Wir haben unsere Klassen so aufgebaut, dass interne Daten nicht direkt ver√§ndert werden k√∂nnen. Stattdessen kamen private Attribute und Properties zum Einsatz. Dadurch konnten wir sicherstellen, dass nur g√ºltige Daten gespeichert werden. Gleichzeitig blieb die Struktur √ºbersichtlich. Diese Art von Kapselung hat unser Verst√§ndnis f√ºr objektorientiertes Design vertieft und den Code stabiler gemacht.

### 5. Iteratives Arbeiten mit User Stories

Wir haben das Projekt in kleine Schritte unterteilt. Jede **User Story** stand f√ºr eine konkrete Funktion. Diese wurde einzeln geplant, umgesetzt und getestet. Erst wenn eine Story abgeschlossen war, ging es zur n√§chsten. Dieses schrittweise Vorgehen war hilfreich, um den Fortschritt zu verfolgen und Fehler fr√ºh zu erkennen. Es entstand ein klarer Arbeitsrhythmus, der sich gut steuern liess.

### 6. Verbindung von Frontend und Backend

**Frontend** und **Backend** greifen ineinander. Das wurde besonders bei √Ñnderungen in der Logik deutlich. Als wir zum Beispiel neue Pr√ºfungen in `booking_manager.py` eingef√ºhrt haben, mussten wir auch den `input_helper.py` anpassen. Sonst h√§tten Nutzer keine g√ºltigen Eingaben mehr machen koennen. Solche Zusammenh√§nge zu erkennen, war wichtig f√ºr eine stabile Anwendung.

### 7. Umgang mit SQLite und SQL-Skripten

Die Arbeit mit SQL-Dateien war anfangs fehleranf√§llig. Besonders beim Wiederverwenden von bestehenden Tabellen kam es schnell zu Konflikten. Wir haben gelernt, dass die Datenbank geleert oder neu erstellt werden muss, bevor SQL-Dateien erneut eingespielt werden. Nur so konnten doppelte Eintraege oder fehlerhafte Verkn√ºpfungen vermieden werden.

## Hilfsmittel & Quellen

### Genutzte Hilfsmittel

F√ºr die Umsetzung unseres Hotelreservierungssystems haben wir verschiedene **Hilfsmittel zur Unterst√ºtzung beim Lernen und Verstehen** eingesetzt.

#### W3Schools & PythonTutor
- [**w3schools.com/python**](https://www.w3schools.com/python/): Hier konnten wir zentrale Sprachkonzepte wie Listen, Klassen oder Schleifen nachschlagen und mit Beispielen testen.
- [**pythontutor.com**](https://pythontutor.com/): Diente uns als **visuelles Debugging-Tool**, um Codezeile f√ºr Codezeile nachzuvollziehen.

#### ChatGPT
ChatGPT haben wir haupts√§chlich zur **Fehlersuche und Kl√§rung von Verst√§ndnisfragen** genutzt. Besonders hilfreich war es beim **Analysieren von Tracebacks** und beim **Erkl√§ren von Zusammenh√§ngen** im Code. Auf vollst√§ndige Codegenerierung haben wir bewusst verzichtet, um unsere eigene Architektur sowie das eigene Verst√§ndnis nicht zu gef√§hrden.

---

### üìö Quellenverzeichnis

- Moodle-Unterlagen zum Modul **AEP**
- Inhalte aus den **Live-Vorlesungen**
- [https://www.w3schools.com/python/](https://www.w3schools.com/python/)
- [https://pythontutor.com/](https://pythontutor.com/)
- **ChatGPT**, als Werkzeug zur Fehlersuche, Syntaxkl√§rung und Strukturhilfe
